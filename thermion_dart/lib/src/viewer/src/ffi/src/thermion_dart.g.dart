// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
@ffi.DefaultAsset('package:thermion_dart/thermion_dart.dart')
library;

import 'dart:ffi' as ffi;

@ffi.Native<
    ffi.Pointer<ffi.Void> Function(LoadFilamentResourceFromOwner,
        FreeFilamentResourceFromOwner, ffi.Pointer<ffi.Void>)>(isLeaf: true)
external ffi.Pointer<ffi.Void> make_resource_loader(
  LoadFilamentResourceFromOwner loadFn,
  FreeFilamentResourceFromOwner freeFn,
  ffi.Pointer<ffi.Void> owner,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void destroy_filament_viewer(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Pointer<TSceneManager> Function(ffi.Pointer<TViewer>)>(
    isLeaf: true)
external ffi.Pointer<TSceneManager> Viewer_getSceneManager(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Pointer<TEngine> Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external ffi.Pointer<TEngine> Viewer_getEngine(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TEngine>, EntityId)>(
    isLeaf: true)
external ffi.Pointer<TCamera> Engine_getCameraComponent(
  ffi.Pointer<TEngine> tEngine,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TEngine>, EntityId, double4x4)>(
    isLeaf: true)
external void Engine_setTransform(
  ffi.Pointer<TEngine> tEngine,
  int entity,
  double4x4 transform,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.IntPtr, ffi.Uint32, ffi.Uint32)>(isLeaf: true)
external void create_render_target(
  ffi.Pointer<TViewer> viewer,
  int texture,
  int width,
  int height,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void clear_background_image(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>, ffi.Bool)>(isLeaf: true)
external void set_background_image(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> path,
  bool fillHeight,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Bool)>(isLeaf: true)
external void set_background_image_position(
  ffi.Pointer<TViewer> viewer,
  double x,
  double y,
  bool clamp,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Float,
        ffi.Float)>(isLeaf: true)
external void set_background_color(
  ffi.Pointer<TViewer> viewer,
  double r,
  double g,
  double b,
  double a,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Int)>(isLeaf: true)
external void set_tone_mapping(
  ffi.Pointer<TViewer> viewer,
  int toneMapping,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float)>(isLeaf: true)
external void set_bloom(
  ffi.Pointer<TViewer> viewer,
  double strength,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>)>(
    isLeaf: true)
external void load_skybox(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> skyboxPath,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>, ffi.Float)>(isLeaf: true)
external void load_ibl(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> iblPath,
  double intensity,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Float,
        ffi.Float)>(isLeaf: true)
external void create_ibl(
  ffi.Pointer<TViewer> viewer,
  double r,
  double g,
  double b,
  double intensity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Float>)>(
    isLeaf: true)
external void rotate_ibl(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Float> rotationMatrix,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void remove_skybox(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void remove_ibl(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    EntityId Function(
        ffi.Pointer<TViewer>,
        ffi.Uint8,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Bool)>(isLeaf: true)
external int add_light(
  ffi.Pointer<TViewer> viewer,
  int type,
  double colour,
  double intensity,
  double posX,
  double posY,
  double posZ,
  double dirX,
  double dirY,
  double dirZ,
  double falloffRadius,
  double spotLightConeInner,
  double spotLightConeOuter,
  double sunAngularRadius,
  double sunHaloSize,
  double sunHaloFallof,
  bool shadows,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, EntityId)>(isLeaf: true)
external void remove_light(
  ffi.Pointer<TViewer> viewer,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void clear_lights(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, EntityId, ffi.Float, ffi.Float,
        ffi.Float)>(isLeaf: true)
external void set_light_position(
  ffi.Pointer<TViewer> viewer,
  int light,
  double x,
  double y,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, EntityId, ffi.Float, ffi.Float,
        ffi.Float)>(isLeaf: true)
external void set_light_direction(
  ffi.Pointer<TViewer> viewer,
  int light,
  double x,
  double y,
  double z,
);

@ffi.Native<
    EntityId Function(ffi.Pointer<TSceneManager>, ffi.Pointer<ffi.Char>,
        ffi.Int, ffi.Bool)>(isLeaf: true)
external int load_glb(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Char> assetPath,
  int numInstances,
  bool keepData,
);

@ffi.Native<
    EntityId Function(ffi.Pointer<TSceneManager>, ffi.Pointer<ffi.Void>,
        ffi.Size, ffi.Bool, ffi.Int, ffi.Int)>(isLeaf: true)
external int load_glb_from_buffer(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Void> data,
  int length,
  bool keepData,
  int priority,
  int layer,
);

@ffi.Native<
    EntityId Function(ffi.Pointer<TSceneManager>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>, ffi.Bool)>(isLeaf: true)
external int load_gltf(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Char> assetPath,
  ffi.Pointer<ffi.Char> relativePath,
  bool keepData,
);

@ffi.Native<EntityId Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external int create_instance(
  ffi.Pointer<TSceneManager> sceneManager,
  int id,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external int get_instance_count(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<EntityId>)>(isLeaf: true)
external void get_instances(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<EntityId> out,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void set_main_camera(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<EntityId Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external int get_main_camera(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TViewer>, EntityId, ffi.Pointer<ffi.Char>)>(isLeaf: true)
external bool set_camera(
  ffi.Pointer<TViewer> viewer,
  int entity,
  ffi.Pointer<ffi.Char> nodeName,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Bool)>(isLeaf: true)
external void set_view_frustum_culling(
  ffi.Pointer<TViewer> viewer,
  bool enabled,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TViewer>,
        ffi.Uint64,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> buf, ffi.Size size,
                    ffi.Pointer<ffi.Void> data)>>,
        ffi.Pointer<ffi.Void>)>(isLeaf: true)
external bool render(
  ffi.Pointer<TViewer> viewer,
  int frameTimeInNanos,
  ffi.Pointer<ffi.Void> pixelBuffer,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> buf, ffi.Size size,
                  ffi.Pointer<ffi.Void> data)>>
      callback,
  ffi.Pointer<ffi.Void> data,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Uint8>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void capture(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Uint8> pixelBuffer,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Void>, ffi.Uint32,
        ffi.Uint32)>(isLeaf: true)
external void create_swap_chain(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Void> window,
  int width,
  int height,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void destroy_swap_chain(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float)>(isLeaf: true)
external void set_frame_interval(
  ffi.Pointer<TViewer> viewer,
  double interval,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Uint32, ffi.Uint32)>(
    isLeaf: true)
external void update_viewport(
  ffi.Pointer<TViewer> viewer,
  int width,
  int height,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void scroll_begin(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Float)>(isLeaf: true)
external void scroll_update(
  ffi.Pointer<TViewer> viewer,
  double x,
  double y,
  double z,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void scroll_end(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Bool)>(isLeaf: true)
external void grab_begin(
  ffi.Pointer<TViewer> viewer,
  double x,
  double y,
  bool pan,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float, ffi.Float)>(
    isLeaf: true)
external void grab_update(
  ffi.Pointer<TViewer> viewer,
  double x,
  double y,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void grab_end(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Float>, ffi.Int)>(isLeaf: true)
external void apply_weights(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Char> entityName,
  ffi.Pointer<ffi.Float> weights,
  int count,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Float>, ffi.Int)>(isLeaf: true)
external bool set_morph_target_weights(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Float> morphData,
  int numWeights,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TSceneManager>,
        EntityId,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Int>,
        ffi.Int,
        ffi.Int,
        ffi.Float)>(isLeaf: true)
external bool set_morph_animation(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Float> morphData,
  ffi.Pointer<ffi.Int> morphIndices,
  int numMorphTargets,
  int numFrames,
  double frameLengthInMs,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(
        ffi.Pointer<TSceneManager>, TMaterialKey)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance> create_material_instance(
  ffi.Pointer<TSceneManager> sceneManager,
  TMaterialKey materialConfig,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(
        ffi.Pointer<TSceneManager>)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance> create_unlit_material_instance(
  ffi.Pointer<TSceneManager> sceneManager,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>,
        ffi.Pointer<TMaterialInstance>)>(isLeaf: true)
external void destroy_material_instance(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<TMaterialInstance> instance,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void clear_morph_animation(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void reset_to_rest_pose(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        EntityId,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float)>(isLeaf: true)
external void add_bone_animation(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> frameData,
  int numFrames,
  double frameLengthInMs,
  double fadeOutInSecs,
  double fadeInInSecs,
  double maxDelta,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Float>)>(isLeaf: true)
external void get_local_transform(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<ffi.Float> arg2,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int,
        ffi.Pointer<ffi.Float>, ffi.Int)>(isLeaf: true)
external void get_rest_local_transforms(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  int skinIndex,
  ffi.Pointer<ffi.Float> out,
  int numBones,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Float>)>(isLeaf: true)
external void get_world_transform(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<ffi.Float> arg2,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Int,
        ffi.Pointer<ffi.Float>)>(isLeaf: true)
external void get_inverse_bind_matrix(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> arg4,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Int,
        ffi.Pointer<ffi.Float>)>(isLeaf: true)
external bool set_bone_transform(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> transform,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Bool,
        ffi.Bool, ffi.Bool, ffi.Float, ffi.Float)>(isLeaf: true)
external void play_animation(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int index,
  bool loop,
  bool reverse,
  bool replaceActive,
  double crossfade,
  double startOffset,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Int)>(isLeaf: true)
external void set_animation_frame(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int animationIndex,
  int animationFrame,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(
    isLeaf: true)
external void stop_animation(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int index,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external int get_animation_count(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Char>, ffi.Int)>(isLeaf: true)
external void get_animation_name(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Char> outPtr,
  int index,
);

@ffi.Native<ffi.Float Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(
    isLeaf: true)
external double get_animation_duration(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int index,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(
    isLeaf: true)
external int get_bone_count(
  ffi.Pointer<TSceneManager> sceneManager,
  int assetEntity,
  int skinIndex,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>(isLeaf: true)
external void get_bone_names(
  ffi.Pointer<TSceneManager> sceneManager,
  int assetEntity,
  ffi.Pointer<ffi.Pointer<ffi.Char>> outPtr,
  int skinIndex,
);

@ffi.Native<
    EntityId Function(
        ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Int)>(isLeaf: true)
external int get_bone(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  int skinIndex,
  int boneIndex,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Float>)>(isLeaf: true)
external bool set_transform(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<ffi.Float> transform,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external bool update_bone_matrices(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, EntityId,
        ffi.Pointer<ffi.Char>, ffi.Int)>(isLeaf: true)
external void get_morph_target_name(
  ffi.Pointer<TSceneManager> sceneManager,
  int assetEntity,
  int childEntity,
  ffi.Pointer<ffi.Char> outPtr,
  int index,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId, EntityId)>(
    isLeaf: true)
external int get_morph_target_name_count(
  ffi.Pointer<TSceneManager> sceneManager,
  int assetEntity,
  int childEntity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, EntityId)>(isLeaf: true)
external void remove_entity(
  ffi.Pointer<TViewer> viewer,
  int asset,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void clear_entities(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Bool Function(
        ffi.Pointer<TSceneManager>,
        EntityId,
        ffi.Pointer<ffi.Char>,
        ffi.Int,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float)>(isLeaf: true)
external bool set_material_color(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Char> meshName,
  int materialIndex,
  double r,
  double g,
  double b,
  double a,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void transform_to_unit_cube(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Float,
        ffi.Float, ffi.Float, ffi.Bool)>(isLeaf: true)
external void queue_position_update(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  double x,
  double y,
  double z,
  bool relative,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Float,
        ffi.Float, ffi.Float, ffi.Float, ffi.Float)>(isLeaf: true)
external void queue_relative_position_update_world_axis(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  double viewportX,
  double viewportY,
  double x,
  double y,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Float,
        ffi.Float)>(isLeaf: true)
external void queue_position_update_from_viewport_coords(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  double viewportX,
  double viewportY,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Float,
        ffi.Float, ffi.Float, ffi.Float, ffi.Float, ffi.Bool)>(isLeaf: true)
external void queue_rotation_update(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  double rads,
  double x,
  double y,
  double z,
  double w,
  bool relative,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Float,
        ffi.Float, ffi.Float)>(isLeaf: true)
external void set_position(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  double x,
  double y,
  double z,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Float,
        ffi.Float, ffi.Float, ffi.Float, ffi.Float)>(isLeaf: true)
external void set_rotation(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  double rads,
  double x,
  double y,
  double z,
  double w,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Float)>(
    isLeaf: true)
external void set_scale(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  double scale,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>, ffi.Float, ffi.Float, ffi.Float)>(isLeaf: true)
external void set_camera_exposure(
  ffi.Pointer<TCamera> camera,
  double aperture,
  double shutterSpeed,
  double sensitivity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, double4x4)>(isLeaf: true)
external void set_camera_model_matrix(
  ffi.Pointer<TCamera> camera,
  double4x4 matrix,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TViewer>, EntityId)>(
    isLeaf: true)
external ffi.Pointer<TCamera> get_camera(
  ffi.Pointer<TViewer> viewer,
  int entity,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 get_camera_model_matrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 get_camera_view_matrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 get_camera_projection_matrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 get_camera_culling_projection_matrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Pointer<ffi.Double> Function(ffi.Pointer<TCamera>)>(
    isLeaf: true)
external ffi.Pointer<ffi.Double> get_camera_frustum(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>, double4x4, ffi.Double, ffi.Double)>(isLeaf: true)
external void set_camera_projection_matrix(
  ffi.Pointer<TCamera> camera,
  double4x4 matrix,
  double near,
  double far,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TCamera>, ffi.Double, ffi.Double, ffi.Double,
        ffi.Double, ffi.Bool)>(isLeaf: true)
external void set_camera_projection_from_fov(
  ffi.Pointer<TCamera> camera,
  double fovInDegrees,
  double aspect,
  double near,
  double far,
  bool horizontal,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double get_camera_focal_length(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getFocalLength(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getNear(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double Camera_getCullingFar(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 Camera_getViewMatrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<double4x4 Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double4x4 Camera_getModelMatrix(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double get_camera_near(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external double get_camera_culling_far(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Float Function(ffi.Pointer<TCamera>, ffi.Bool)>(isLeaf: true)
external double get_camera_fov(
  ffi.Pointer<TCamera> camera,
  bool horizontal,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, ffi.Float)>(isLeaf: true)
external void set_camera_focus_distance(
  ffi.Pointer<TCamera> camera,
  double focusDistance,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, _ManipulatorMode, ffi.Double,
        ffi.Double, ffi.Double)>(isLeaf: true)
external void set_camera_manipulator_options(
  ffi.Pointer<TViewer> viewer,
  int mode,
  double orbitSpeedX,
  double orbitSpeedY,
  double zoomSpeed,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TCamera>, double4x4, ffi.Double, ffi.Double)>(isLeaf: true)
external void Camera_setCustomProjectionWithCulling(
  ffi.Pointer<TCamera> camera,
  double4x4 projectionMatrix,
  double near,
  double far,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TCamera>, double4x4)>(isLeaf: true)
external void Camera_setModelMatrix(
  ffi.Pointer<TCamera> camera,
  double4x4 modelMatrix,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TCamera>, ffi.Double, ffi.Double, ffi.Double,
        ffi.Double)>(isLeaf: true)
external void Camera_setLensProjection(
  ffi.Pointer<TCamera> camera,
  double near,
  double far,
  double aspect,
  double focalLength,
);

@ffi.Native<EntityId Function(ffi.Pointer<TCamera>)>(isLeaf: true)
external int Camera_getEntity(
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Pointer<TEntityManager> Function(ffi.Pointer<TEngine>)>(
    isLeaf: true)
external ffi.Pointer<TEntityManager> Engine_getEntityManager(
  ffi.Pointer<TEngine> engine,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TSceneManager>)>(
    isLeaf: true)
external ffi.Pointer<TCamera> SceneManager_createCamera(
  ffi.Pointer<TSceneManager> sceneManager,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, ffi.Pointer<TCamera>)>(isLeaf: true)
external void SceneManager_destroyCamera(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, ffi.Pointer<TCamera>)>(isLeaf: true)
external void SceneManager_setCamera(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<TCamera> camera,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<TSceneManager>)>(isLeaf: true)
external int SceneManager_getCameraCount(
  ffi.Pointer<TSceneManager> sceneManager,
);

@ffi.Native<
    ffi.Pointer<TCamera> Function(
        ffi.Pointer<TSceneManager>, ffi.Size)>(isLeaf: true)
external ffi.Pointer<TCamera> SceneManager_getCameraAt(
  ffi.Pointer<TSceneManager> sceneManager,
  int index,
);

@ffi.Native<ffi.Pointer<TCamera> Function(ffi.Pointer<TSceneManager>)>(
    isLeaf: true)
external ffi.Pointer<TCamera> SceneManager_getActiveCamera(
  ffi.Pointer<TSceneManager> sceneManager,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Char>)>(isLeaf: true)
external int hide_mesh(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Char> meshName,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Char>)>(isLeaf: true)
external int reveal_mesh(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Char> meshName,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Bool)>(isLeaf: true)
external void set_post_processing(
  ffi.Pointer<TViewer> viewer,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Bool)>(isLeaf: true)
external void set_shadows_enabled(
  ffi.Pointer<TViewer> viewer,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Int)>(isLeaf: true)
external void set_shadow_type(
  ffi.Pointer<TViewer> viewer,
  int shadowType,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float, ffi.Float)>(
    isLeaf: true)
external void set_soft_shadow_options(
  ffi.Pointer<TViewer> viewer,
  double penumbraScale,
  double penumbraRatioScale,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Bool, ffi.Bool, ffi.Bool)>(isLeaf: true)
external void set_antialiasing(
  ffi.Pointer<TViewer> viewer,
  bool msaa,
  bool fxaa,
  bool taa,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    EntityId entityId, ffi.Int x, ffi.Int y)>>)>(isLeaf: true)
external void filament_pick(
  ffi.Pointer<TViewer> viewer,
  int x,
  int y,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(EntityId entityId, ffi.Int x, ffi.Int y)>>
      callback,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<TSceneManager>, EntityId)>(isLeaf: true)
external ffi.Pointer<ffi.Char> get_name_for_entity(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
);

@ffi.Native<
    EntityId Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Char>)>(isLeaf: true)
external int find_child_entity_by_name(
  ffi.Pointer<TSceneManager> sceneManager,
  int parent,
  ffi.Pointer<ffi.Char> name,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Bool)>(
    isLeaf: true)
external int get_entity_count(
  ffi.Pointer<TSceneManager> sceneManager,
  int target,
  bool renderableOnly,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Bool,
        ffi.Pointer<EntityId>)>(isLeaf: true)
external void get_entities(
  ffi.Pointer<TSceneManager> sceneManager,
  int target,
  bool renderableOnly,
  ffi.Pointer<EntityId> out,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Bool)>(isLeaf: true)
external ffi.Pointer<ffi.Char> get_entity_name_at(
  ffi.Pointer<TSceneManager> sceneManager,
  int target,
  int index,
  bool renderableOnly,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Bool)>(isLeaf: true)
external void set_recording(
  ffi.Pointer<TViewer> viewer,
  bool recording,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>)>(
    isLeaf: true)
external void set_recording_output_directory(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> outputDirectory,
);

@ffi.Native<ffi.Void Function()>(isLeaf: true)
external void ios_dummy();

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>(isLeaf: true)
external void thermion_flutter_free(
  ffi.Pointer<ffi.Void> ptr,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        EntityId,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(EntityId entityId1, EntityId entityId2)>>,
        ffi.Bool)>(isLeaf: true)
external void add_collision_component(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(EntityId entityId1, EntityId entityId2)>>
      callback,
  bool affectsCollidingTransform,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void remove_collision_component(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external bool add_animation_component(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void remove_animation_component(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
);

@ffi.Native<
    EntityId Function(
        ffi.Pointer<TSceneManager>,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Pointer<ffi.Uint16>,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<TMaterialInstance>,
        ffi.Bool)>(isLeaf: true)
external int create_geometry(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Float> vertices,
  int numVertices,
  ffi.Pointer<ffi.Float> normals,
  int numNormals,
  ffi.Pointer<ffi.Float> uvs,
  int numUvs,
  ffi.Pointer<ffi.Uint16> indices,
  int numIndices,
  int primitiveType,
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool keepData,
);

@ffi.Native<EntityId Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external int get_parent(
  ffi.Pointer<TSceneManager> sceneManager,
  int child,
);

@ffi.Native<EntityId Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external int get_ancestor(
  ffi.Pointer<TSceneManager> sceneManager,
  int child,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, EntityId, EntityId, ffi.Bool)>(isLeaf: true)
external void set_parent(
  ffi.Pointer<TSceneManager> sceneManager,
  int child,
  int parent,
  bool preserveScaling,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void test_collisions(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(
    isLeaf: true)
external void set_priority(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  int priority,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, ffi.Pointer<EntityId>)>(isLeaf: true)
external void get_gizmo(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<EntityId> out,
);

@ffi.Native<Aabb2 Function(ffi.Pointer<TSceneManager>, EntityId)>(isLeaf: true)
external Aabb2 get_bounding_box(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        EntityId,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Float>)>(isLeaf: true)
external void get_bounding_box_to_out(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Float> minX,
  ffi.Pointer<ffi.Float> minY,
  ffi.Pointer<ffi.Float> maxX,
  ffi.Pointer<ffi.Float> maxY,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, ffi.Int, ffi.Bool)>(
    isLeaf: true)
external void set_layer_visibility(
  ffi.Pointer<TSceneManager> sceneManager,
  int layer,
  bool visible,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(
    isLeaf: true)
external void set_visibility_layer(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int layer,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    EntityId entityId, ffi.Int x, ffi.Int y)>>)>(isLeaf: true)
external void pick_gizmo(
  ffi.Pointer<TSceneManager> sceneManager,
  int x,
  int y,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(EntityId entityId, ffi.Int x, ffi.Int y)>>
      callback,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, ffi.Bool)>(
    isLeaf: true)
external void set_gizmo_visibility(
  ffi.Pointer<TSceneManager> sceneManager,
  bool visible,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Float,
        ffi.Float, ffi.Float)>(isLeaf: true)
external void set_stencil_highlight(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  double r,
  double g,
  double b,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId)>(
    isLeaf: true)
external void remove_stencil_highlight(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int,
        ffi.Pointer<ffi.Char>, ffi.Float)>(isLeaf: true)
external void set_material_property_float(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int materialIndex,
  ffi.Pointer<ffi.Char> property,
  double value,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int,
        ffi.Pointer<ffi.Char>, ffi.Int)>(isLeaf: true)
external void set_material_property_int(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int materialIndex,
  ffi.Pointer<ffi.Char> property,
  int value,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int,
        ffi.Pointer<ffi.Char>, double4)>(isLeaf: true)
external void set_material_property_float4(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int materialIndex,
  ffi.Pointer<ffi.Char> property,
  double4 value,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Bool)>(isLeaf: true)
external void set_material_depth_write(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int materialIndex,
  bool enabled,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        EntityId,
        ffi.Pointer<ffi.Uint8>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint8>,
        ffi.Uint32,
        ffi.Uint32)>(isLeaf: true)
external void unproject_texture(
  ffi.Pointer<TViewer> viewer,
  int entity,
  ffi.Pointer<ffi.Uint8> input,
  int inputWidth,
  int inputHeight,
  ffi.Pointer<ffi.Uint8> out,
  int outWidth,
  int outHeight,
);

@ffi.Native<
    ffi.Pointer<ffi.Void> Function(ffi.Pointer<TSceneManager>,
        ffi.Pointer<ffi.Uint8>, ffi.Size)>(isLeaf: true)
external ffi.Pointer<ffi.Void> create_texture(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Uint8> data,
  int length,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, ffi.Pointer<ffi.Void>)>(isLeaf: true)
external void destroy_texture(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Void> texture,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>(isLeaf: true)
external void apply_texture_to_material(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  ffi.Pointer<ffi.Void> texture,
  ffi.Pointer<ffi.Char> parameterName,
  int materialIndex,
);

@ffi.Native<
    ffi.Pointer<TMaterialInstance> Function(
        ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(isLeaf: true)
external ffi.Pointer<TMaterialInstance> get_material_instance_at(
  ffi.Pointer<TSceneManager> sceneManager,
  int entity,
  int materialIndex,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Bool)>(
    isLeaf: true)
external void MaterialInstance_setDepthWrite(
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TMaterialInstance>, ffi.Bool)>(
    isLeaf: true)
external void MaterialInstance_setDepthCulling(
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool enabled,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> renderCallbackOwner)>>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<TViewer> viewer)>>)>(isLeaf: true)
external void create_filament_viewer_render_thread(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<ffi.Void> platform,
  ffi.Pointer<ffi.Char> uberArchivePath,
  ffi.Pointer<ffi.Void> loader,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> renderCallbackOwner)>>
      renderCallback,
  ffi.Pointer<ffi.Void> renderCallbackOwner,
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TViewer> viewer)>>
      callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        ffi.Pointer<ffi.Void>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void create_swap_chain_render_thread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Void> surface,
  int width,
  int height,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void destroy_swap_chain_render_thread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.IntPtr, ffi.Uint32, ffi.Uint32,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void create_render_target_render_thread(
  ffi.Pointer<TViewer> viewer,
  int nativeTextureId,
  int width,
  int height,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void destroy_filament_viewer_render_thread(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void render_render_thread(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Uint8>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void capture_render_thread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<FilamentRenderCallback Function(FilamentRenderCallback)>(
    isLeaf: true)
external FilamentRenderCallback make_render_callback_fn_pointer(
  FilamentRenderCallback arg0,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Bool,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void set_rendering_render_thread(
  ffi.Pointer<TViewer> viewer,
  bool rendering,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void request_frame_render_thread(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float)>(isLeaf: true)
external void set_frame_interval_render_thread(
  ffi.Pointer<TViewer> viewer,
  double frameInterval,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Float,
        ffi.Float)>(isLeaf: true)
external void set_background_color_render_thread(
  ffi.Pointer<TViewer> viewer,
  double r,
  double g,
  double b,
  double a,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void clear_background_image_render_thread(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>, ffi.Bool,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void set_background_image_render_thread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> path,
  bool fillHeight,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Float, ffi.Float, ffi.Bool)>(isLeaf: true)
external void set_background_image_position_render_thread(
  ffi.Pointer<TViewer> viewer,
  double x,
  double y,
  bool clamp,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Int)>(isLeaf: true)
external void set_tone_mapping_render_thread(
  ffi.Pointer<TViewer> viewer,
  int toneMapping,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Float)>(isLeaf: true)
external void set_bloom_render_thread(
  ffi.Pointer<TViewer> viewer,
  double strength,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void load_skybox_render_thread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> skyboxPath,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> onComplete,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>, ffi.Pointer<ffi.Char>, ffi.Float)>(isLeaf: true)
external void load_ibl_render_thread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.Char> iblPath,
  double intensity,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void remove_skybox_render_thread(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void remove_ibl_render_thread(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TViewer>,
            ffi.Uint8,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Bool,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>>)>(
    isLeaf: true)
external void add_light_render_thread(
  ffi.Pointer<TViewer> viewer,
  int type,
  double colour,
  double intensity,
  double posX,
  double posY,
  double posZ,
  double dirX,
  double dirY,
  double dirZ,
  double falloffRadius,
  double spotLightConeInner,
  double spotLightConeOuter,
  double sunAngularRadius,
  double sunHaloSize,
  double sunHaloFallof,
  bool shadows,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>> callback,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, EntityId)>(isLeaf: true)
external void remove_light_render_thread(
  ffi.Pointer<TViewer> viewer,
  int entityId,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>)>(isLeaf: true)
external void clear_lights_render_thread(
  ffi.Pointer<TViewer> viewer,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<ffi.Char>,
            ffi.Int,
            ffi.Bool,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>>)>(
    isLeaf: true)
external void load_glb_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Char> assetPath,
  int numInstances,
  bool keepData,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<ffi.Uint8>,
            ffi.Size,
            ffi.Int,
            ffi.Bool,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>>)>(
    isLeaf: true)
external void load_glb_from_buffer_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Uint8> data,
  int length,
  int numInstances,
  bool keepData,
  int priority,
  int layer,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Bool,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>>)>(
    isLeaf: true)
external void load_gltf_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Char> assetPath,
  ffi.Pointer<ffi.Char> relativePath,
  bool keepData,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>> callback,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>>)>(
    isLeaf: true)
external void create_instance_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>, EntityId,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void remove_entity_render_thread(
  ffi.Pointer<TViewer> viewer,
  int asset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TViewer>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void clear_entities_render_thread(
  ffi.Pointer<TViewer> viewer,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TViewer>, EntityId, ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void set_camera_render_thread(
  ffi.Pointer<TViewer> viewer,
  int asset,
  ffi.Pointer<ffi.Char> nodeName,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Float>, ffi.Int)>(isLeaf: true)
external void apply_weights_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  ffi.Pointer<ffi.Char> entityName,
  ffi.Pointer<ffi.Float> weights,
  int count,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>, EntityId, ffi.Int, ffi.Int)>(isLeaf: true)
external void set_animation_frame_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  int animationIndex,
  int animationFrame,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, ffi.Int)>(
    isLeaf: true)
external void stop_animation_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  int index,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>(
    isLeaf: true)
external void get_animation_count_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        EntityId,
        ffi.Pointer<ffi.Char>,
        ffi.Int,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void get_animation_name_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  ffi.Pointer<ffi.Char> outPtr,
  int index,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TSceneManager>,
        EntityId,
        EntityId,
        ffi.Pointer<ffi.Char>,
        ffi.Int,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void get_morph_target_name_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int assetEntity,
  int childEntity,
  ffi.Pointer<ffi.Char> outPtr,
  int index,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId, EntityId,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>)>(
    isLeaf: true)
external void get_morph_target_name_count_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  int childEntity,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            EntityId,
            ffi.Pointer<ffi.Float>,
            ffi.Int,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void set_morph_target_weights_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  ffi.Pointer<ffi.Float> morphData,
  int numWeights,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void update_bone_matrices_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            EntityId,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<ffi.Float>,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>)>(
    isLeaf: true)
external void set_bone_transform_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int asset,
  int skinIndex,
  int boneIndex,
  ffi.Pointer<ffi.Float> transform,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>> callback,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<TViewer>, ffi.Bool)>(isLeaf: true)
external void set_post_processing_render_thread(
  ffi.Pointer<TViewer> viewer,
  bool enabled,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<TSceneManager>, EntityId,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void reset_to_rest_pose_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  int entityId,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<TSceneManager>,
            ffi.Pointer<ffi.Float>,
            ffi.Int,
            ffi.Pointer<ffi.Float>,
            ffi.Int,
            ffi.Pointer<ffi.Float>,
            ffi.Int,
            ffi.Pointer<ffi.Uint16>,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<TMaterialInstance>,
            ffi.Bool,
            ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>>)>(
    isLeaf: true)
external void create_geometry_render_thread(
  ffi.Pointer<TSceneManager> sceneManager,
  ffi.Pointer<ffi.Float> vertices,
  int numVertices,
  ffi.Pointer<ffi.Float> normals,
  int numNormals,
  ffi.Pointer<ffi.Float> uvs,
  int numUvs,
  ffi.Pointer<ffi.Uint16> indices,
  int numIndices,
  int primitiveType,
  ffi.Pointer<TMaterialInstance> materialInstance,
  bool keepData,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(EntityId)>> callback,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<TViewer>,
        EntityId,
        ffi.Pointer<ffi.Uint8>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint8>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>(isLeaf: true)
external void unproject_texture_render_thread(
  ffi.Pointer<TViewer> viewer,
  int entity,
  ffi.Pointer<ffi.Uint8> input,
  int inputWidth,
  int inputHeight,
  ffi.Pointer<ffi.Uint8> out,
  int outWidth,
  int outHeight,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> callback,
);

final class TCamera extends ffi.Opaque {}

final class TMaterialInstance extends ffi.Opaque {}

final class TEngine extends ffi.Opaque {}

final class TEntityManager extends ffi.Opaque {}

final class TViewer extends ffi.Opaque {}

final class TSceneManager extends ffi.Opaque {}

final class TMaterialKey extends ffi.Struct {
  @ffi.Bool()
  external bool doubleSided;

  @ffi.Bool()
  external bool unlit;

  @ffi.Bool()
  external bool hasVertexColors;

  @ffi.Bool()
  external bool hasBaseColorTexture;

  @ffi.Bool()
  external bool hasNormalTexture;

  @ffi.Bool()
  external bool hasOcclusionTexture;

  @ffi.Bool()
  external bool hasEmissiveTexture;

  @ffi.Bool()
  external bool useSpecularGlossiness;

  @ffi.Int()
  external int alphaMode;

  @ffi.Bool()
  external bool enableDiagnostics;

  external UnnamedUnion1 unnamed;

  @ffi.Uint8()
  external int baseColorUV;

  @ffi.Bool()
  external bool hasClearCoatTexture;

  @ffi.Uint8()
  external int clearCoatUV;

  @ffi.Bool()
  external bool hasClearCoatRoughnessTexture;

  @ffi.Uint8()
  external int clearCoatRoughnessUV;

  @ffi.Bool()
  external bool hasClearCoatNormalTexture;

  @ffi.Uint8()
  external int clearCoatNormalUV;

  @ffi.Bool()
  external bool hasClearCoat;

  @ffi.Bool()
  external bool hasTransmission;

  @ffi.Bool()
  external bool hasTextureTransforms;

  @ffi.Uint8()
  external int emissiveUV;

  @ffi.Uint8()
  external int aoUV;

  @ffi.Uint8()
  external int normalUV;

  @ffi.Bool()
  external bool hasTransmissionTexture;

  @ffi.Uint8()
  external int transmissionUV;

  @ffi.Bool()
  external bool hasSheenColorTexture;

  @ffi.Uint8()
  external int sheenColorUV;

  @ffi.Bool()
  external bool hasSheenRoughnessTexture;

  @ffi.Uint8()
  external int sheenRoughnessUV;

  @ffi.Bool()
  external bool hasVolumeThicknessTexture;

  @ffi.Uint8()
  external int volumeThicknessUV;

  @ffi.Bool()
  external bool hasSheen;

  @ffi.Bool()
  external bool hasIOR;

  @ffi.Bool()
  external bool hasVolume;
}

final class UnnamedUnion1 extends ffi.Union {
  external UnnamedStruct1 unnamed;

  external UnnamedStruct2 unnamed1;
}

final class UnnamedStruct1 extends ffi.Struct {
  @ffi.Bool()
  external bool hasMetallicRoughnessTexture;

  @ffi.Uint8()
  external int metallicRoughnessUV;
}

final class UnnamedStruct2 extends ffi.Struct {
  @ffi.Bool()
  external bool hasSpecularGlossinessTexture;

  @ffi.Uint8()
  external int specularGlossinessUV;
}

final class double4 extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;

  @ffi.Double()
  external double z;

  @ffi.Double()
  external double w;
}

final class double4x4 extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col1;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col2;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col3;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> col4;
}

final class Aabb2 extends ffi.Struct {
  @ffi.Float()
  external double minX;

  @ffi.Float()
  external double minY;

  @ffi.Float()
  external double maxX;

  @ffi.Float()
  external double maxY;
}

final class ResourceBuffer extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  @ffi.Int32()
  external int size;

  @ffi.Int32()
  external int id;
}

final class ResourceLoaderWrapper extends ffi.Struct {
  external LoadFilamentResource loadResource;

  external FreeFilamentResource freeResource;

  external LoadFilamentResourceFromOwner loadFromOwner;

  external FreeFilamentResourceFromOwner freeFromOwner;

  external ffi.Pointer<ffi.Void> owner;

  external LoadFilamentResourceIntoOutPointer loadToOut;
}

typedef LoadFilamentResource
    = ffi.Pointer<ffi.NativeFunction<LoadFilamentResourceFunction>>;
typedef LoadFilamentResourceFunction = ResourceBuffer Function(
    ffi.Pointer<ffi.Char> uri);
typedef FreeFilamentResource
    = ffi.Pointer<ffi.NativeFunction<FreeFilamentResourceFunction>>;
typedef FreeFilamentResourceFunction = ffi.Void Function(ResourceBuffer);
typedef DartFreeFilamentResourceFunction = void Function(ResourceBuffer);
typedef LoadFilamentResourceFromOwner
    = ffi.Pointer<ffi.NativeFunction<LoadFilamentResourceFromOwnerFunction>>;
typedef LoadFilamentResourceFromOwnerFunction = ResourceBuffer Function(
    ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>);
typedef FreeFilamentResourceFromOwner
    = ffi.Pointer<ffi.NativeFunction<FreeFilamentResourceFromOwnerFunction>>;
typedef FreeFilamentResourceFromOwnerFunction = ffi.Void Function(
    ResourceBuffer, ffi.Pointer<ffi.Void>);
typedef DartFreeFilamentResourceFromOwnerFunction = void Function(
    ResourceBuffer, ffi.Pointer<ffi.Void>);
typedef LoadFilamentResourceIntoOutPointer = ffi
    .Pointer<ffi.NativeFunction<LoadFilamentResourceIntoOutPointerFunction>>;
typedef LoadFilamentResourceIntoOutPointerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Char> uri, ffi.Pointer<ResourceBuffer> out);
typedef DartLoadFilamentResourceIntoOutPointerFunction = void Function(
    ffi.Pointer<ffi.Char> uri, ffi.Pointer<ResourceBuffer> out);

/// This header replicates most of the methods in ThermionDartApi.h.
/// It represents the interface for:
/// - invoking those methods that must be called on the main Filament engine thread
/// - setting up a render loop
typedef EntityId = ffi.Int32;
typedef DartEntityId = int;
typedef _ManipulatorMode = ffi.Int32;
typedef Dart_ManipulatorMode = int;
typedef FilamentRenderCallback
    = ffi.Pointer<ffi.NativeFunction<FilamentRenderCallbackFunction>>;
typedef FilamentRenderCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> owner);
typedef DartFilamentRenderCallbackFunction = void Function(
    ffi.Pointer<ffi.Void> owner);

const int __bool_true_false_are_defined = 1;

const int true1 = 1;

const int false1 = 0;
